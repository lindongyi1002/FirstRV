## Unit0 RISC-V学习建议
---
- [x] 熟悉RISC-V架构，了解其特点和优势。
- [ ] 学习RISC-V的指令集，掌握其指令的格式、功能和使用方法。
- [ ] 学习RISC-V的编程模型，掌握其寄存器、内存和异常处理等方面的知识。
- [ ] 学习RISC-V的工具链，包括编译器、汇编器、链接器和调试器等。
- [ ] 学习RISC-V的应用开发，包括操作系统、驱动程序和应用程序等方面的知识。
此外，可以参考一些开源项目，如tinyriscv项目，来加深对RISC-V的理解。

## Unit1 计算机硬件的操作数(计算机组成与设计-软硬件接口, P47)
---
### 1. 与高级语言程序不同, 算数指令的==操作数==会受到限制;

### 2. 它们必须取自==寄存器==, 而寄存器数量有限并内建于硬件的特殊位置, 寄存器是硬件设计的基本元素;

### 3. RISC-V架构中, 寄存器的大小可以为64/32位;
- 64位称为双字(Double Word, DW);
- 32位称为字(Word, W);
- 1字(Word) = 4字节(Byte) = 32位(bit);

### 4. 当前RISC-V计算机上的寄存器数量通常为32个;

### 5. 因此RISC-V算术指令的三个操作数必须从32个寄存器中选择;

### 6. RISC-V约定在"x"后面跟一个寄存器编号来表示, 如x22, x12等;
![800](https://picgo-1318211300.cos.ap-beijing.myqcloud.com/FigBed/Pasted%20image%2020230416203722.png)

### 7. RISC-V指令中的算数运算只作用于寄存器, 因此, RISC-V必须包含在内存和寄存器之间传输数据的指令, 这些指令称为数据传输指令;

### 8. 常数或立即数在程序加载过程中会存放到内存中, 需要先从内存中加载到寄存器中再进行算数运算;
- 可以通过先从内存中加载立即数, 再进行运算的方式进行运行,如
```basic
    ld   x9,AddrConstant4(x3)
    add  x22,x22,x9
```
- 另一个版本的算术指令, 它的其中一个操作数是常数(立即数), 如addi(add immediate):
```basic
    addi x22,x22,4
```

 ### 9. RISC-V的专用寄存器x0硬连接到常数0;

 ### 10. 现在所有计算机都是用二进制补码来表示有符号数(主要是指令中的立即数);
- 正数三码合一, 原码, 反码, 补码相等;
- 负数的反码等于除符号位外的所有位0变1, 1变0;
- 负数的补码等于反码加1;
- 负数的补码可以通过将除符号位外的所有位0变1, 1变0后再加1得到原码;
    如补码13'b1_1111_1110_1100的原码为13'b1_0000_0001_0100 = 13'd(-20)

## Unit2 指令表示 
---
### 1. 一条指令的每一段称为一个字段;

### 2. RISC-V指令都是32位长;

### 3. 把指令的数字表示称作机器语言;

### 4. RISC-V指令格式:
 ![800](https://picgo-1318211300.cos.ap-beijing.myqcloud.com/FigBed/Pasted%20image%2020230416220951.png)0
|R-type|I-type|S-type|B-type|U-type|J-type|
|---|---|---|---|---|---|
|寄存器到寄存器|用于短immediate和访存load|Store|条件跳转Branch|长immediate|非条件跳转Jump|
- 下图为RV32I指令集的指令, 其中rs2和rs1(source register)是源操作数寄存器, rd(destination register)是目标寄存器
![800](https://picgo-1318211300.cos.ap-beijing.myqcloud.com/FigBed/Pasted%20image%2020230417111057.png)
    - shamt字段(shift amount)用于指定位移指令(如slli, srli和srai)的位移量;
    - pred
    - succ
    - csr字段(Control and Status Register)代表控制和状态寄存器
    - zimm字段
    - 
### 5. 将if-then-else语句编译为条件分支指令
 - 有如下C语言的if语句:
    ```C
    if(i == j)
        f = g + h;
    else
        f = g - h;
```
    -  f,g,h,i,j对应x19~x23这5个寄存器;
    - 其对应的RISC-V汇编代码为:
    ```basic
    bne  x22,x23,Else    //if x22 and x23 is not equal, go to Else branch
    add  x19,x20,x21     //x19 = x20 + x21
    beq  x0,x0,Exit      //if x0 and x0 is equal, go to Exit branch, must be equal(x0 === 0)
    Else: sub x19,x20, x21    //x19 = x20 - x21
    Exit:
```

### 6. 将while循环语句编译为条件分支指令
- 有如花C语言的while语句:
    ```C
    while(save[i] == k)
        i += 1;
    ```
- i和k对应于寄存器x22和x24, 数组save的基址保存在x25中, 有临时寄存器x10;
- 其对应的RISC-V汇编代码为:
```basic
    Loop: slli x10,x22,3    //x10 = x22 << 3, 左移三位相当于x10 = x22 * 8, 即将索引i乘以8后存放在临时寄存器x10中
    add  x10,x10,x25        //把数组save的基址和i*8后的值相加得到save[i]的地址, 再放到x10中
    ld   x9,0[x10]          //访问的内存的地址为x10中存放的地址, 并将数据存放到x9
    bne  x9,x24,Exit        //进行循环判断, 如果x9(save[i])和x24(k)不相等则跳转到Exit branch, 相等则继续执行下一行
    addi x22,x22,1          //立即数加, 即从内存中取1与x22寄存器中的值相加, i = i + 1
    beq  x0,x0,Loop         //branch to Loop and continue run
    Exit:
```

### 7. 过程(函数)
    - 过程是一个根据给定参数执行特定任务的已存储的子程序;
    - 过程或函数是编程人员用于结构化编程的一种工具, 两者均有助于提高程序的可理解性和代码的可重用性;
- 执行过程时, 程序有如下6个步骤:
    >1. 将参数放在过程可以访问到的位置;
    >2. 将控制转交给过程;
    >3. 获取过程所需的存储资源;
    >4. 执行所需的任务;
    >5. 将结果值放在调用程序可以访问到的位置;
    >6. 将控制返回到初始点(原进程), 因为过程可以从程序中的多个点调用.
- 有如下C代码包含一sum函数:
```C
    ...
    sum(a, b);
    ...
    int sum(int x, int y)
    {
        return x + y;
    }
    ...
```
其对应的32位RISC-V汇编代码为(a, b存放于x8, x9寄存器):
```basic
    1000 addi x10,x8,0    //把x8寄存器中的保存的值移动到x10中, 专门用于传递参数(step1);
    1004 addi x11,x9,0    //把x9寄存器中的保存的值移动到x11中, 专门用于传递参数(step1);
    1008 jal  x1,sum      //跳转到地址为2000的sum过程, 同时将下一条指令的地址(1012 = 1008(当前指令地址) + 4)存放于x1中, 即将返回地址存放于返回地址寄存器(step2);
    1012 ...
    ...
    2000 sum: add x10,x10,x11    //执行sum过程中的add运算, 即将x10与x11中的值相加(step3 & step4),  并存储与x10中(step5);  
    2004 jalr x0,0(x1)    //跳转到地址为x1 + 0的位置(即起始点1012), 并将返回地址存储于x0中(由于x0硬连接为0, 故认为丢弃返回地址,即为don't care) (step6);
    ...
```

### 8. 程序计数器(Program Counter, PC) = 指令地址寄存器
    在存储程序概念中,需要一个寄存器来保存当前指定指令的地址, 该寄存器即为指令地址寄存器;
- 执行程序时, 需要根据PC中存放的地址, 去存储系统中取出对应地址的指令;

### 9. 栈(Stack)
    栈是一种被组织成后进先出(LIFO)队列并用于寄存器换出的数据结构;
- 压栈(push stack): 向栈中添加元素;
- 弹栈(pop stack): 从栈中移除元素;
- RISC-V中栈指针(Stack Pointer, sp)是寄存器x2(sp);
#### (1) 编译一个没有调用其他过程的C过程(*叶子过程, Leaf Procedure*)
>    有如下C过程:
```C
    long long int leaf_example(long long int g, long long int h, long long int i, long long int j)
    {
        long long int f;
        f = (g + h) - (i + j);
        return f;
    }
```
>    编译后的64位 RISC-V汇编代码如下(g, h, i, j对应于参数寄存器x10, x11, x12, x13, f对应x20):
```basic
    leaf_example:    
    //把x5, x6, x20中的旧值存入栈中, 再使用x5, x6, x20时就不会影响存入栈中的值, 过程结束后, 再从栈中弹出旧值给x5, x6, x20
    addi sp,sp,-24      //在栈中创建3个双字空间(3*8Byte = 24Byte);
    sd   x5,16(sp)      //把x5寄存器中的旧值压入栈中;
    sd   x6,8(sp)       //把x6寄存器中的旧值压入栈中;
    sd   x20,0(sp)      //把x20寄存器中的旧值压入栈中;
    add  x5,x10,x11     //x5 = g + h
    add  x6,x12,x13     //x6 = i + j
    sub  x20,x5,x6      //f = x5 - x6
    addi x10,x20,0      //把x20复制到x10
    ld   x20,0(sp)      //从栈中将0位置处的值弹出给x20;
    ld   x6,8(sp)       //从栈中将8位置处的值弹出给x6;
    ld   x5,16(sp)      //从栈中将16位置处的值弹出给x5;
    addi sp,sp,24       //删除栈中的3个双字空间;
    jalr x0,0(x1)       //返回原进程(起始点)
```
>    过程调用之前, 之中, 之后栈的变化情况:
    ![800](https://picgo-1318211300.cos.ap-beijing.myqcloud.com/FigBed/Pasted%20image%2020230418165053.jpg)
#### (2) 嵌套过程(*非叶子过程, Non-Leaf Procedure*)
>    有如下C过程用于计算阶乘:
```C
    long long int fact (long long int n)  
    {  
        if (n < 1) return (1);  
        else return n * fact(n - 1);
    }
```
>    编译后的64位RISC-V汇编代码为(n对应x10寄存器):==还没搞清楚==
```basic
fact:
   addi sp,sp,-16    //开辟2个双字的栈空间
   sd   x1,8(sp)     //把x1寄存器中的旧值放入栈中
   sd   x10,0(sp)    //把x10寄存器中的旧值放入栈中
   addi x5,x10,-1    //计算x5 = n - 1
   bge  x5,x0,L1     //如果n - 1 >= 0, 则跳转到L1 branch, 否则运行下一地址的命令
   adi x10,x0,1      //此时n - 1 < 0, 则x10 = 1
   addi sp,sp,16     //恢复栈空间, 因为n<1时, x1和x10的值不会变, 故不关心已存入栈的值
   jalr x0,0(x1)     //跳转回x1地址, 即原进程(起始点)
L1:
   addi x10,x10,-1   //此时n - 1 >= 0, 实现 n = n - 1
   jal  x1,fact      //跳转到fact branch, 同时将下一条指令的地址(PC + 8)存入x1中
   addi x6,x10,0
   ld   x10,0(sp)
   ld   x1,8(sp)
   addi sp,sp,16
   mul  x10,x10,x6
   jalr x0,0(x1)
```

### 10. 人机交互
- 加载无符号字节(lbu): 该指令从内存中加载一个字节, 将其放在寄存器的最右边8位;
- 存储字节(sb): 该指令从寄存器的最右边8位去除一个字节并将其存入内存中;
- 加载无符号半字(load half unsigned, lhu): 从内存中读取一个半字, 将它放在寄存器的最右边16位, 用零填充最左边的48位;
- 加载半字(load halfword, lh): 将半字视为有符号数, 通过符号扩展填充最左边的48位;
- 存储半字(store halfword): 从寄存器的最右边16位取半字并将其写入内存;
#### (1)编译字符串复制程序, 展示如何使用C语言字符串
>    有如何C代码:
```C
    void strcpy (char x[], char y[])  
    { size_t i;  
      i = 0;  
      while ((x[i]=y[i])!='\0')  
        i += 1;  
    }
```
>    对应的编译后的RISC-V汇编代码如下(x和y的基址放在x10和x11中, 而i再x19中):
```basic
    strcpy:  
      addi sp,sp,-8       // adjust stack for 1 doubleword  
      sd   x19,0(sp)      // push x19  
      add  x19,x0,x0      // i=0  
    L1: add  x5,x19,x10   // x5 = addr of y[i]  
      lbu  x6,0(x5)       // x6 = y[i]  x6存的是y[i]的值
      add  x7,x19,x10     // x7 = addr of x[i]  x7存的是x[i]的地址
      sb   x6,0(x7)       // x[i] = y[i]  把x6中的值, 存到x7的地址中,即x[i] = y[i]
      beq  x6,x0,L2       // if y[i] == 0 then exit  
      addi x19,x19, 1     // i = i + 1  
      jal  x0,L1          // next iteration of loop  
    L2: ld   x19,0(sp)    // restore saved x19  
      addi sp,sp,8        // pop 1 doubleword from stack  
      jalr x0,0(x1)       // and return
```

### 11. 对大立即数的RISC-V编址和寻址
#### (1) 大立即数
- 取立即数高位指令(load upper immediate, lui): 用于将20位的常数加载到寄存器的31位-12位;
>  如有如下64位常量要加载到寄存器x19中:
```
    00000000_00000000_00000000_00000000_00000000_00111101_00000101_00000000
```
>    对应的RISC-V汇编代码为:
```basic
    lui  x19, 976         //976(decimal) = 0000_0000_0011_0000, 将该值放置在x19的31-12位;
    addi x19, x19, 1280   //1280(decimal) = 0000_0101_0000_0000, 将该值与x19的原值相加, 即将该值放置在x19的低12位
```
#### (2) 分支中的寻址
- RISC-V中的分支指令使用SB型的指令格式, 只能跳转到偶数地址, 如:
```basic
    bne  x10, x11, 2000
```
- 无条件跳转-链接指令(jal)是唯一使用UJ型格式的指令;
- PC相对寻址: 一种寻址方式, 它的地址是PC和指令中的常量之和;
- 寻址模式:根据对操作数和(或)地址使用的不同, 在多种寻址方式中加以区分的寻址机制
    1. 立即数寻址: 操作数是指令本身的常量;
    2. 寄存器寻址: 操作数在寄存器中;
    3. 基址或偏移寻址: 操作数存于内存中, 其地址是寄存器和指令中的常量之和;
    4. PC相对寻址: 分支地址是PC和指令中的常量之和;
#### (3) RISC-V中条件分支指令的字节范围是多少?
- 条件分支指令属于B type指令形式, B type有13位立即数, 最高位是符号位, 所以寻址范围为2^12 = 4K, 
- 由于RISC-V使用字节寻址, 所以4K代表4K字节;
- 由于条件分支指令使用PC相对寻址方式, 所以其字节范围应该在PC +/- 4K, 即分支前后地址范围各大约为4K;
#### (4) RISC-V中跳转-链接指令(jal)的字节地址范围是多少?
- jal指令中包含20位立即数, 故2^20 = 1M字节;
- 同样由于PC相对寻址方式, 所以其字节地址范围为分支前后各大约1M字节;

### 12. 同步

### 13.翻译并启动程序
- C语言的转换层次结构(编译器-汇编器-连接器-加载器):
    ![800](https://picgo-1318211300.cos.ap-beijing.myqcloud.com/FigBed/Pasted%20image%2020230422123335.png)
- 伪指令: 一种汇编指令的常见变体, 可以把它看作汇编语言指令;
    - 如:
```basic
    li   x9, 123    //load immediate value 123 to x9
    //汇编器将该指令转换成与一下指令的等效的机器语言:
    addi x9, x0, 123
```
- 即使在RISC-V机器语言中不存在 'li' 这条指令, RISC-V汇编器也能够将其识别并转换为正确的机器语言;
- 加载器: 将目标程序放在主存中以准备执行的系统程序;

## Unit3 处理器实现
---
- 所有类型的指令在读取寄存器后都使用算术逻辑单元(Arithmetic Logical Unit, ALU).

### 流水线冒险
#### (1) 结构冒险(structural hazard)
    - 即硬件不支持多条指令在同一时钟周期执行;
e.g. 如果流水线结构中只有1个存储器, 如果有四条指令, 则可能会发生第一条指令从存储器中取数据的同时第四条指令从统一存储器取指令, 就会发生结构冒险.

#### (2)数据冒险(data hazard)
    - 由于一个步骤必须等待另一个步骤完成而导致的流水线停顿叫做数据冒险.
- 一种基本的解决方案为**前递(forwarding)或旁路(bypassing)**: 即提前从缓冲中取到数据, 而不是等到数据到达寄存器或存储器.
    - 前递这个名称来源于将结果从前一条指令直接传递给后面一条指令的思想;
    - 旁路这个名称来源于将结果绕过寄存器堆,直接传递给需要他的单元的思想.
- 前递不能解决所有的流水线停顿.
- 因为并不是所有的指令都会写回寄存器, 所以并不能在不应该前递的时候将数据前递出去.
    - 一种简单的解决方案是检查RegWrite信号是否有效: 检查流水线寄存器在EX和MEM阶段的WB控制字段以确定RegWrite信号是否有效, 如果有效则需要前递, 反之不需要. 比如目标寄存器rd为x0时, 就不希望前递非零的结果值.
- 载入-使用型数据冒险(load-use data hazard): 一种特定的数据冒险, 指当载入指令要取的指令还没取回时, 其他指令就需要该数据的情况.
- 流水线停顿(pipeline stall): 俗称气泡(bubble), 为了解决冒险而实施的一种阻塞.

#### (3)控制冒险(分支冒险)
    - 在需要一条指令的结果做出决定时, 其他指令正在执行.
    - 也称为分支冒险, 由于渠道的指令并不是所需要的,或者指令的地址流向不是流水线所预期的,导致正确的指令无法再正确的时钟周期内执行.
1. 第一种解决办法: 停顿
2. **第二种解决办法: 预测**
    - 预测是解决分支冒险的方法. 它预测分支的结果并沿预测方向执行, 而不是等分支结果确定后才开始执行, 如果预测正确,这个方法不会减慢流水线, 但是如果预测错误, 则必须从正确的分支地址处重新启动流水线.
    - 动态硬件预测器可以根据每个条件分支的指令行为进行预测, 并在程序生命周期内可能改变条件分支的预测结果.
    - 动态预测的常用实现方法是保存每个条件分支是否发生分支的历史记录, 然后根据最近的过去行为来预测未来.
3. 第三种解决办法: 延迟决定(延迟转移)

- 空指令: 一种不执行任何操作, 不改变任何状态的指令. 
